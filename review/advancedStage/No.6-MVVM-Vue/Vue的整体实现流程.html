<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

//响应式：vue如何监听data的每一个属性的变化？
//模板解析引擎：vue的模板如何被解析，指令如何处理
//渲染：vue的模板如何被渲染成html，以及渲染过程
//渲染：vue的模板如何被渲染成html,以及渲染过程
<h4>第一步:解析模板成render函数</h4>
<ol>
    <li>// 1,with的用法</li>
    <li>// 2,模板中所有信息都被render函数包含</li>
    <li>// 3,模板中用到的data中的属性,都变成了js变量</li>
    <li>// 4,模板中的v-model v-for,v-on都变成了js逻辑</li>
    <li>// 5,render()返回了vnode</li>
</ol>
<h4>// 第二步:响应式开始监听</h4>
<ol>
    <li>// 1,Object.defineProperty</li>
    <li>// 2,将data的属性代理到vm上</li>
    <li>// 3,实现get获取和set的设置</li>
</ol>
<h4>// 第三步:首次渲染,显示页面,切绑定依赖
</h4>
<ol>
    <li>// 1,初次渲染,执行updateComponent,执行</li>
    <li>// 2,执行render函数,会访问道vm.list和vm.title</li>
    <li>// 3,就会被响应式中的get监听到</li>
    <li>// (data中许多属性可能不被用到,可能被用到,被用到的才会走get,不被用到的不走get,未走get中的属性,set的时候 无需关心, 避免不必要的渲染）</li>
    <li>// 4,执行updateComponent,会走到vdom的patch方法</li>
    <li>// 5,patch()将vnode渲染成DOM初次渲染完成</li>
</ol>
<h4>// 第四步:data属性变化,除发rerender
</h4>
<ol>
    <li>// 1,修改属性,被响应式的set监听到</li>
    <li>// 2,set中执行updateComponent</li>
    <li>// 3,set中执行updateComponent会重新执行,</li>
    <li>// 4,生成的vnode和prevVnode,通过patch进行对比，渲染到html中</li>
</ol>
解析模板用render->响应监听用difineProperty->渲染显示更新组件render-Vnode内容更新用rerender
<script>

</script>
</body>
</html>
